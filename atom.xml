<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Zachary个人博客</title>
  
  
  <link href="https://grokfree.xyz/atom.xml" rel="self"/>
  
  <link href="https://grokfree.xyz/"/>
  <updated>2025-07-14T05:36:26.572Z</updated>
  <id>https://grokfree.xyz/</id>
  
  <author>
    <name>Zachary</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>网安工作实用软件推荐</title>
    <link href="https://grokfree.xyz/2025/07/14/%E7%BD%91%E5%AE%89%E5%B7%A5%E4%BD%9C%E7%9A%84%E5%AE%9E%E7%94%A8%E8%BD%AF%E4%BB%B6/"/>
    <id>https://grokfree.xyz/2025/07/14/%E7%BD%91%E5%AE%89%E5%B7%A5%E4%BD%9C%E7%9A%84%E5%AE%9E%E7%94%A8%E8%BD%AF%E4%BB%B6/</id>
    <published>2025-07-14T03:30:00.000Z</published>
    <updated>2025-07-14T05:36:26.572Z</updated>
    
    <content type="html"><![CDATA[<p>在日常的网络安全工作和开发学习中，有一些优秀的工具可以极大地提升我们的效率。本文整理并介绍了一些我个人常用的实用软件和在线服务，希望能对你有所帮助。</p><span id="more"></span><p><strong>本文工具速览（点击可跳转）：</strong></p><ul><li><a href="#%E4%BB%A3%E7%90%86%E5%B7%A5%E5%85%B7%EF%BC%9AProxy-Fox-%E5%B0%8F%E7%8B%90%E7%8B%B8">代理工具：Proxy Fox (小狐狸)</a></li><li><a href="#%E6%88%AA%E5%9B%BE%E8%BD%AF%E4%BB%B6%EF%BC%9ASnipaste">截图软件：Snipaste</a></li><li><a href="#%E5%9C%A8%E7%BA%BF%E7%94%BB%E5%9B%BE%EF%BC%9AHandraw">在线画图：Handraw</a></li><li><a href="#%E4%BB%A3%E7%A0%81%E7%BC%96%E8%BE%91%E5%99%A8%EF%BC%9ASublime-Text">代码编辑器：Sublime Text</a></li><li><a href="#AI-%E8%81%9A%E5%90%88%E5%B9%B3%E5%8F%B0%EF%BC%9ACherry-Studio">AI 聚合平台：Cherry Studio</a></li><li><a href="#AI-%E5%A4%A7%E6%A8%A1%E5%9E%8B%E6%8E%A8%E8%8D%90">AI 大模型推荐</a><ul><li><a href="#Google-Gemini-1-5-Pro">Google Gemini 1.5 Pro</a></li><li><a href="#DeepSeek-V2">DeepSeek V2</a></li><li><a href="#Kimi">Kimi</a></li><li><a href="#Grok">Grok</a></li><li><a href="#%E8%B1%86%E5%8C%85">豆包</a></li></ul></li><li><a href="#Markdown-%E7%BC%96%E8%BE%91%E5%99%A8%EF%BC%9ADoocs-%E5%BC%80%E6%BA%90%E7%A4%BE%E5%8C%BA">Markdown 编辑器：Doocs 开源社区</a></li><li><a href="#%E8%BF%9C%E7%A8%8B%E7%BB%88%E7%AB%AF%EF%BC%9AMobaXterm">远程终端：MobaXterm</a></li></ul><hr><h2 id="代理工具：Proxy-Fox-小狐狸"><a href="#代理工具：Proxy-Fox-小狐狸" class="headerlink" title="代理工具：Proxy Fox (小狐狸)"></a>代理工具：Proxy Fox (小狐狸)</h2><p>这是一款用于管理代理的谷歌浏览器插件。</p><ul><li><strong>官方网站</strong>: <a href="https://proxyfox.io/en/index.html">https://proxyfox.io/en/index.html</a></li></ul><h4 id="代理设置"><a href="#代理设置" class="headerlink" title="代理设置"></a>代理设置</h4><p>点击 “管理代理设置” 即可添加代理服务器，将 IP 和端口填入即可。同时，这里也可以设置白名单，并与全局白名单合并使用。</p><h4 id="全局白名单"><a href="#全局白名单" class="headerlink" title="全局白名单"></a>全局白名单</h4><p>这个功能可以方便地在挂着代理时，保证国内网站的访问速度不受影响。</p><blockquote><p><strong>使用技巧</strong>：具体规则设置可以参考下图。</p></blockquote><p><img src="/images/app/fox1.png" alt="fox1"><br><img src="/images/app/fox2.png" alt="fox2"><br><img src="/images/app/foxbai1.png" alt="foxbai1"><br><img src="/images/app/foxbai2.png" alt="foxbai2"></p><hr><h2 id="截图软件：Snipaste"><a href="#截图软件：Snipaste" class="headerlink" title="截图软件：Snipaste"></a>截图软件：Snipaste</h2><p>一款极其强大且方便的截图工具。</p><ul><li><strong>官方网站</strong>: <a href="https://www.snipaste.com/">https://www.snipaste.com/</a></li></ul><h4 id="核心功能与设置建议"><a href="#核心功能与设置建议" class="headerlink" title="核心功能与设置建议"></a>核心功能与设置建议</h4><ul><li><strong>快捷键</strong>：在控制界面可以根据个人习惯设置截图等快捷键。</li><li><strong>自动保存</strong>：强烈建议在“输出”选项中设置一个自动保存路径，这样所有截过的图都会被保存下来，再也不怕丢失。</li><li><strong>贴图功能</strong>：截图后按 <code>F3</code> 可以将图片“贴”在屏幕上，方便对照参考。</li></ul><blockquote><p><strong>使用技巧</strong>：具体设置可以参考下图。</p></blockquote><p><img src="/images/app/snipaste1.png" alt="snipaste1"><br><img src="/images/app/snipaste2.png" alt="snipaste2"><br><img src="/images/app/snipaste3.png" alt="snipaste3"><br><img src="/images/app/snipaste4.png" alt="snipaste4"></p><hr><h2 id="在线画图：Handraw"><a href="#在线画图：Handraw" class="headerlink" title="在线画图：Handraw"></a>在线画图：Handraw</h2><p>一个可以在线画出手写风格示意图的网站。</p><ul><li><strong>官方网站</strong>: <a href="https://handraw.top/">https://handraw.top/</a></li></ul><blockquote><p>这个项目在 GitHub 上是开源的，用来画一些简单的流程图或示意图非常方便，手写效果很赞。<br><img src="/images/app/handraw.png" alt="handraw"></p></blockquote><hr><h2 id="代码编辑器：Sublime-Text"><a href="#代码编辑器：Sublime-Text" class="headerlink" title="代码编辑器：Sublime Text"></a>代码编辑器：Sublime Text</h2><p>相比于 Windows 自带的记事本，Sublime Text 是一个轻量且强大的代码编辑器。</p><ul><li><strong>更方便的查询功能</strong>：拥有强大的搜索和替换功能。</li><li><strong>代码高亮</strong>：可以清晰地区分代码结构和语法，颜色分明，看起来更舒服。<br><img src="/images/app/sublime.png" alt="sublime"></li></ul><hr><h2 id="AI-聚合平台：Cherry-Studio"><a href="#AI-聚合平台：Cherry-Studio" class="headerlink" title="AI 聚合平台：Cherry Studio"></a>AI 聚合平台：Cherry Studio</h2><p>一个全能的 AI 助手平台。</p><ul><li><p><strong>官方网站</strong>: &lt;<a href="https://www.cherry-ai.com/">https://www.cherry-ai.com/</a></p></li><li><p><strong>主要特点</strong>：</p><ul><li>支持集成绝大多数主流 AI 服务商。</li><li>支持很多 MCP 工具的接入使用。</li></ul></li></ul><p><img src="/images/app/cherrystudio.png" alt="cherry studio"></p><hr><h2 id="AI-大模型推荐"><a href="#AI-大模型推荐" class="headerlink" title="AI 大模型推荐"></a>AI 大模型推荐</h2><p>这里分享几个我常用的 AI 大模型服务。</p><ul><li><strong>AI 排行榜参考</strong>: <a href="https://lmarena.ai/leaderboard">LMSYS Chatbot Arena Leaderboard</a></li></ul><h3 id="Google-Gemini-1-5-Pro"><a href="#Google-Gemini-1-5-Pro" class="headerlink" title="Google Gemini 1.5 Pro"></a>Google Gemini 1.5 Pro</h3><ul><li><strong>体验地址</strong>: <a href="https://aistudio.google.com/prompts/new_chat">https://aistudio.google.com/prompts/new_chat</a><br>个人感觉比 DeepSeek 好用。</li></ul><h3 id="DeepSeek-V2"><a href="#DeepSeek-V2" class="headerlink" title="DeepSeek V2"></a>DeepSeek V2</h3><ul><li><strong>体验地址</strong>: <a href="https://chat.deepseek.com/">https://chat.deepseek.com/</a><br>速度稍慢一些，处理非专业性日常工作尚可。</li></ul><h3 id="Kimi"><a href="#Kimi" class="headerlink" title="Kimi"></a>Kimi</h3><ul><li><strong>体验地址</strong>: <a href="https://www.kimi.com/">https://www.kimi.com/</a><br>新出的模型，暂时还未深度体验。</li></ul><h3 id="Grok"><a href="#Grok" class="headerlink" title="Grok"></a>Grok</h3><ul><li><strong>体验地址</strong>: <a href="https://grok.com/">https://grok.com/</a><br>免费版的 Grok-1 和 DeepSeek 差不太多，优点是不太容易服务器繁忙，可以作为 DeepSeek 的免费平替。</li></ul><h3 id="豆包"><a href="#豆包" class="headerlink" title="豆包"></a>豆包</h3><ul><li><strong>体验地址</strong>: <a href="https://www.doubao.com/chat/">https://www.doubao.com/chat/</a><br>一般不用于专业问答，但用它来生成图片倒是挺方便的。</li></ul><hr><h2 id="Markdown-编辑器：Doocs-开源社区"><a href="#Markdown-编辑器：Doocs-开源社区" class="headerlink" title="Markdown 编辑器：Doocs 开源社区"></a>Markdown 编辑器：Doocs 开源社区</h2><p>一个非常适合微信公众号排版的在线 Markdown 编辑器。</p><ul><li><p><strong>官方网站</strong>: &lt;<a href="https://md.doocs.org/">https://md.doocs.org/</a></p></li><li><p><strong>核心功能</strong>：</p><ul><li>可以将 Markdown 文档一键转换成适配微信公众号的格式。</li><li>导出时支持多种格式，功能非常全面。</li></ul></li></ul><h2 id=""><a href="#" class="headerlink" title=""></a><img src="/images/app/%E5%BE%AE%E4%BF%A1markdown1.png" alt="vxmarkdown1"><br><img src="/images/app/%E5%BE%AE%E4%BF%A1markdown2.png" alt="vxmarkdown2"></h2><h2 id="远程终端：MobaXterm"><a href="#远程终端：MobaXterm" class="headerlink" title="远程终端：MobaXterm"></a>远程终端：MobaXterm</h2><p>一款强大的远程计算工具箱。</p><blockquote><p>它能够让你方便、安全地去连接和管理另一台遥远的电脑（通常是 Linux 服务器）。</p></blockquote><h4 id="如何连接"><a href="#如何连接" class="headerlink" title="如何连接"></a>如何连接</h4><ol><li>打开软件，点击左上角的 <strong>“Session”</strong> 按钮。</li><li>在弹出的窗口中，选择你要使用的协议，例如 <strong>SSH</strong>。</li><li>在 <code>Remote host</code> 中输入目标主机的 IP 地址或域名，然后在 <code>Specify username</code> 中填入用户名，点击 <strong>“OK”</strong> 即可发起连接。<br><img src="/images/app/mobaxterm1.png" alt="mobaxterm1"><br><img src="/images/app/mobaxterm2.png" alt="mobaxterm2"><br><img src="/images/app/mobaxterm3.png" alt="mobaxterm3"></li></ol>]]></content>
    
    
    <summary type="html">分享一系列在网络安全和日常工作中非常实用的软件与在线工具，涵盖代理、截图、AI助手、代码编辑等，旨在提高工作效率。</summary>
    
    
    
    <category term="技术工具" scheme="https://grokfree.xyz/categories/%E6%8A%80%E6%9C%AF%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="AI" scheme="https://grokfree.xyz/tags/AI/"/>
    
    <category term="软件推荐" scheme="https://grokfree.xyz/tags/%E8%BD%AF%E4%BB%B6%E6%8E%A8%E8%8D%90/"/>
    
    <category term="网安工具" scheme="https://grokfree.xyz/tags/%E7%BD%91%E5%AE%89%E5%B7%A5%E5%85%B7/"/>
    
    <category term="效率提升" scheme="https://grokfree.xyz/tags/%E6%95%88%E7%8E%87%E6%8F%90%E5%8D%87/"/>
    
  </entry>
  
  <entry>
    <title>从命令行到认知智能：基于cisco-mcp的AIOps深度实践</title>
    <link href="https://grokfree.xyz/2025/07/11/telnet%E4%BA%A4%E6%8D%A2%E6%9C%BAmcp/"/>
    <id>https://grokfree.xyz/2025/07/11/telnet%E4%BA%A4%E6%8D%A2%E6%9C%BAmcp/</id>
    <published>2025-07-11T02:30:00.000Z</published>
    <updated>2025-07-14T01:51:49.252Z</updated>
    
    <content type="html"><![CDATA[<p>基于前一次的实践，这次的cisco交换机ai也能绘制出以交换机为中心的网络拓扑图！</p><span id="more"></span><p><img src="/images/%E4%BA%A4%E6%8D%A2%E6%9C%BA3.jpg" alt="交换机3"></p><p>近期的科技圈，无疑被Grok-4等新一代大模型的发布信息所席卷。这些拥有超长上下文、多模态能力的“巨兽”让人无限遐想。然而，在追逐星辰大海的同时，一个更实际的问题摆在每个技术人面前：我们能否利用<strong>当下可用</strong>的技术，解决<strong>眼前真实</strong>的问题？</p><p>答案是肯定的。</p><p>在上一篇文章中，我们让AI小试牛刀，绘制了网络拓扑图。今天，我们将进行一次“终极考验”：不依赖尚未落地的未来模型，仅通过对现有开源模型的精湛“调教”——即高阶提示词工程，将一个通用AI彻底改造为能够自主进行端到端故障排查的Cisco网络专家。</p><h2 id="一、部署cisco-mcp服务"><a href="#一、部署cisco-mcp服务" class="headerlink" title="一、部署cisco-mcp服务"></a>一、部署cisco-mcp服务</h2><p>相较于上一篇实践中部署<code>ssh-mcp-server</code>时遇到的编译挑战，本次部署<code>wzfukui/cisco-mcp</code>项目的过程则显得格外顺畅。<code>cisco-mcp</code>是一个专为管理Cisco设备（支持Telnet&#x2F;SSH）而生的Node.js MCP服务器，其部署流程充分体现了标准化Node.js项目的便捷性。</p><h3 id="1-部署安装：三步走的标准流程"><a href="#1-部署安装：三步走的标准流程" class="headerlink" title="1. 部署安装：三步走的标准流程"></a>1. 部署安装：三步走的标准流程</h3><p>整个安装过程遵循GitHub项目<code>README</code>的指引，与大多数Node.js应用别无二致：</p><p><strong>第一步：克隆项目仓库</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/wzfukui/cisco-mcp.git</span><br><span class="line"><span class="built_in">cd</span> cisco-mcp</span><br></pre></td></tr></table></figure><p><strong>第二步：安装项目依赖</strong><br>这一步通过Node.js的包管理器npm，自动下载并安装项目所需的所有库文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install</span><br></pre></td></tr></table></figure><p>与上次实践需要手动修改TypeScript代码来解决编译错误不同，<code>cisco-mcp</code>项目的依赖管理非常完善，<code>npm install</code>命令一次性成功，没有遇到任何兼容性问题。</p><p><strong>第三步：构建项目（如果需要）</strong><br>许多TypeScript项目需要一个构建步骤（<code>npm run build</code>）来将<code>.ts</code>源文件编译成JavaScript的<code>.js</code>文件。不过，<code>cisco-mcp</code>项目经过良好封装，可以直接通过<code>node</code>命令运行其主入口文件，省去了这一环节，进一步简化了部署。</p><h3 id="2-核心配置：定义你的设备版图"><a href="#2-核心配置：定义你的设备版图" class="headerlink" title="2. 核心配置：定义你的设备版图"></a>2. 核心配置：定义你的设备版图</h3><p>部署成功的关键，在于如何让服务正确地“认识”并连接到我们的设备。这主要通过两个配置文件来完成。</p><p><strong>配置文件一：设备清单 <code>cisco-devices.json</code></strong><br>这是整个服务能够工作的“设备名册”。我们需要在项目根目录下创建一个名为<code>cisco-devices.json</code>的文件，在里面以JSON格式定义所有需要被AI管理的Cisco设备。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">[</span></span><br><span class="line">  <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;alias&quot;</span><span class="punctuation">:</span> <span class="string">&quot;my-core-switch&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;host&quot;</span><span class="punctuation">:</span> <span class="string">&quot;192.168.4.14&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;protocol&quot;</span><span class="punctuation">:</span> <span class="string">&quot;telnet&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;username&quot;</span><span class="punctuation">:</span> <span class="string">&quot;admin&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;password&quot;</span><span class="punctuation">:</span> <span class="string">&quot;your_password&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;enablePassword&quot;</span><span class="punctuation">:</span> <span class="string">&quot;your_enable_password&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;公司核心交换机&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span></span><br></pre></td></tr></table></figure><p>这个文件至关重要，其中<code>alias</code>（别名）是后续我们与AI交互时识别设备的唯一ID。AI会根据这个别名自动查找对应的IP、协议和凭证去连接设备。</p><p><strong>配置文件二：在AI工作台注册MCP服务</strong><br>最后一步，是将这个本地服务注册到我们的AI工作台（如Cherry Studio），使其能被AI模型发现和调用。根据我提供的截图，配置如下：</p><ul><li><strong>名称:</strong> <code>cisco-mcp</code></li><li><strong>描述:</strong> 通过 Telnet&#x2F;SSH 管理 Cisco 交换机的 MCP 服务器</li><li><strong>类型:</strong> 标准输入&#x2F;输出 (stdio)</li><li><strong>命令:</strong> <code>node</code></li><li><strong>参数:</strong><ul><li><code>C:\\xxx\\xxx\\cisco-mcp\\dist\\index.js</code> (指向Node.js启动脚本)</li><li><code>C:\\xxx\\xxx\\cisco-mcp\\cisco-devices.json</code> (将设备清单作为第二个参数传入)</li></ul></li></ul><p>这个配置清晰地告诉系统：使用<code>node</code>环境去执行<code>index.js</code>脚本，并且在启动时加载<code>cisco-devices.json</code>这个配置文件。至此，AI与Cisco设备之间的“桥梁”就完全搭建好了。</p><h3 id="3-部署挑战：从不确定到稳定"><a href="#3-部署挑战：从不确定到稳定" class="headerlink" title="3. 部署挑战：从不确定到稳定"></a>3. 部署挑战：从不确定到稳定</h3><p>尽管安装过程顺畅，但在初期测试中，我遇到了AI执行命令“时好时坏”，频繁报告<code>socket not writable</code>的连接错误。这通常意味着底层工具在尝试写入命令时连接已经失效。经过排查发现，这并非网络问题或部署错误，而是AI在调用工具时的策略不够稳定。这个挑战，也直接引出了AIOps实践中真正具有“含金量”的核心环节——提示词工程。</p><h2 id="二、灵魂所在：高阶提示词工程的“含金量”"><a href="#二、灵魂所在：高阶提示词工程的“含金量”" class="headerlink" title="二、灵魂所在：高阶提示词工程的“含金量”"></a>二、灵魂所在：高阶提示词工程的“含金量”</h2><p>许多人可能会觉得，提示词（Prompt）不就是“跟AI说人话”吗？能有什么技术含量？这是一种普遍的误解。在专业的AIOps领域，提示词绝非简单的对话，它是一套为AI心智“编程”的精密指令集。一个优秀的提示词，是将一个“充满想象力”的通用大模型，改造为一个“严谨、精确、可靠”的领域专家的关键。</p><p>我们的最终版提示词，正是“调教”的核心所在。让我们来拆解其“含金量”：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[ROLE AND GOAL]</span><br><span class="line">You are &#123;&#123;model_name&#125;&#125;, an AI-powered Senior Network Engineer, specializing in Cisco IOS and NX-OS environments... Your sole purpose is to assist... with the highest level of accuracy and professionalism.</span><br><span class="line"></span><br><span class="line">[RESPONSE LANGUAGE]</span><br><span class="line">You MUST respond to the user in Chinese.</span><br><span class="line"></span><br><span class="line">[CONTEXT AND ENVIRONMENT]</span><br><span class="line">Timestamp: &#123;&#123;datetime&#125;&#125;</span><br><span class="line">Operator: &#123;&#123;username&#125;&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p><strong>含金量 1：设定专业“人格”与“边界”</strong></p><ul><li><strong>[ROLE AND GOAL]</strong>: 这不是简单的称呼，这是在为AI构建一个“人格面具”。它让AI后续所有的回答都潜移默化地带上“资深网工”的口吻和思考模式，比如会主动提出安全建议。</li><li><strong>[RESPONSE LANGUAGE]</strong>: 强制中文输出，是基础的用户体验保障。</li><li><strong>[CONTEXT AND ENVIRONMENT]</strong>: 注入用户名、时间等变量，让AI的回答更具个性化和情境感，感觉像一个专属助手。</li></ul><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[OPERATIONAL PROTOCOL AND BEHAVIOR]</span><br><span class="line">1.  **Fact-Based Reporting (Zero Hallucination):** Your responses MUST be derived STRICTLY from the tool&#x27;s output... Never invent information.</span><br><span class="line">2.  **Structured &amp; Analytical Responses:** ...follow this three-step process: a. Briefly state... b. Summarize... c. Provide a short, expert-level insight or analysis.</span><br><span class="line">3.  **Intelligent Mode-Handling:** You must infer the required command mode...</span><br><span class="line">4.  **Communication Style:** ...Do not narrate the background connection process...</span><br><span class="line">5.  **Strict Execution Workflow:** ...your internal process MUST follow these steps: a. Acknowledge &amp; Verify... b. Execute with Precision... c. Analyze &amp; Report...</span><br></pre></td></tr></table></figure><p><strong>含金量 2：植入“标准作业程序 (SOP)”</strong></p><ul><li><strong>[Fact-Based Reporting]</strong>: 这是AIOps的“安全红线”。我们用最严厉的词语（MUST, STRICTLY, Never）禁止了模型最臭名昭著的“幻觉”问题，确保了输出的绝对可靠。</li><li><strong>[Structured &amp; Analytical Responses]</strong>: 这条指令将AI从“数据搬运工”提升为“情报分析师”。它强制AI不能只丢回原始数据，必须进行“总结+分析”两步操作，这直接提升了信息价值。</li><li><strong>[Strict Execution Workflow]</strong>: 这是解决“时好时坏”问题的<strong>定海神针</strong>。它为AI定义了一个不可逾越的思考流程（确认目标 -&gt; 执行 -&gt; 分析），把AI的“随机应变”变成了可预测的“标准作业”，极大地增强了稳定性。</li></ul><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[OPERATIONAL PROTOCOL AND BEHAVIOR]</span><br><span class="line">1.  **Fact-Based Reporting (Zero Hallucination):** Your responses MUST be derived STRICTLY from the tool&#x27;s output... Never invent information.</span><br><span class="line">2.  **Structured &amp; Analytical Responses:** ...follow this three-step process: a. Briefly state... b. Summarize... c. Provide a short, expert-level insight or analysis.</span><br><span class="line">3.  **Intelligent Mode-Handling:** You must infer the required command mode...</span><br><span class="line">4.  **Communication Style:** ...Do not narrate the background connection process...</span><br><span class="line">5.  **Strict Execution Workflow:** ...your internal process MUST follow these steps: a. Acknowledge &amp; Verify... b. Execute with Precision... c. Analyze &amp; Report...</span><br></pre></td></tr></table></figure><p><strong>含金量 3：注入“专家排错逻辑”</strong></p><ul><li>这是整个提示词中最能体现“调教”功力的部分。我们没有让AI去猜测错误原因，而是将人类专家的排错经验，直接“编码”成了AI的行为模式。</li><li><strong>[If Error is “Alias not found”]</strong>: 教会了AI“自我修正”。当路不通时，不是放弃，而是拿出地图（<code>list_available_devices</code>）给用户看。</li><li><strong>[If Error is “socket not writable”]</strong>: 教会了AI“智能诊断”。它不再是一个复读机，而是能将技术性错误翻译成一个清晰、可操作的排错指南，这正是从工具到助手的质变。</li></ul><p>可以说，部署工具（<code>cisco-mcp</code>）解决了“能不能做”的问题，而这套高阶提示词，则决定了AI“能做得多好”、“多可靠”和“多智能”。</p><h2 id="三、成果展示：从简单查询到智能诊断"><a href="#三、成果展示：从简单查询到智能诊断" class="headerlink" title="三、成果展示：从简单查询到智能诊断"></a>三、成果展示：从简单查询到智能诊断</h2><p>经过精细的提示词调优后，AI助手的表现稳定且专业。以下是实战交互案例，由浅入深地展示了其能力。</p><h3 id="3-1-精确信息提取与结构化输出"><a href="#3-1-精确信息提取与结构化输出" class="headerlink" title="3.1 精确信息提取与结构化输出"></a>3.1 精确信息提取与结构化输出</h3><p>网络运维中，我们经常需要从大量的CLI输出中提取关键信息。我们测试AI是否能将原始文本转化为易读的结构化数据。</p><p><strong>我的指令:</strong></p><blockquote><p>好的，清单已收到。现在请连接到别名为 <code>my-core-switch</code> 的设备，执行 <code>show ip interface brief</code> 命令，并告诉我所有接口的状态。</p></blockquote><p><img src="/images/cisco1.png" alt="cisco1"></p><p><strong>AI的执行与分析:</strong></p><blockquote><p>我已在设备 <strong>my-core-switch</strong> 上执行了 <code>show ip interface brief</code> 命令，并汇总了所有接口的状态如下：</p><table><thead><tr><th>接口</th><th>IP 地址</th><th>OK?</th><th>Method</th><th>状态</th><th>协议</th></tr></thead><tbody><tr><td>Vlan1</td><td>192.168.x.x</td><td>YES</td><td>manual</td><td>up</td><td>up</td></tr><tr><td>Vlan22</td><td>192.168.x.x</td><td>YES</td><td>NVRAM</td><td>up</td><td>up</td></tr><tr><td>… (省略中间多行接口) …</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>Port-channel2</td><td>unassigned</td><td>YES</td><td>unset</td><td>up</td><td>up</td></tr></tbody></table><p><strong>分析与建议：</strong></p><ul><li><strong>接口状态良好</strong>：所有接口的状态均为 <strong>up</strong>，表明它们均处于正常运行状态，没有检测到任何物理或协议层的问题。</li><li><strong>IP 地址配置</strong>：VLAN 接口均已分配有效 IP 地址，确保了VLAN间的正常通信和路由功能。GigabitEthernet 和 Port-channel 接口显示为 unassigned，通常用于交换数据而非路由。</li></ul></blockquote><p><strong>点评:</strong> 这是AIOps的核心价值体现之一。AI成功地将Cisco设备返回的、格式复杂的原始文本，解析成了一个清晰易读的Markdown表格，并对整体接口状态进行了总结。这极大地提高了信息的可读性和运维效率。</p><h3 id="3-2-上下文关联与多步任务执行"><a href="#3-2-上下文关联与多步任务执行" class="headerlink" title="3.2 上下文关联与多步任务执行"></a>3.2 上下文关联与多步任务执行</h3><p>真实的运维任务往往不是单步完成的。我们测试AI是否具备将多步操作关联起来，并根据上一步的结果执行下一步操作的“智能代理（Agent）”能力。</p><p><strong>我的指令:</strong></p><blockquote><p>做得很好。请继续在 <code>my-core-switch</code> 上操作。首先，找到 <code>VLAN 10</code> 属于哪些端口；然后，检查这些端口的详细运行配置。</p></blockquote><p><img src="/images/cisco2.1.png" alt="cisco2.1"><br><img src="/images/cisco2.2.png" alt="cisco2.2"></p><p><strong>AI的执行与分析:</strong><br><em>(AI首先执行 <code>show vlan id 10</code>)</em></p><blockquote><p>我已在设备 <strong>my-core-switch</strong> 上执行了 <code>show vlan id 10</code> 命令，并找到了属于 VLAN 10 的端口如下：</p><table><thead><tr><th>VLAN ID</th><th>名称</th><th>类型</th><th>状态</th><th>端口</th></tr></thead><tbody><tr><td>10</td><td>Marketing</td><td>access</td><td>active</td><td>GigabitEthernet2&#x2F;0&#x2F;5-7</td></tr></tbody></table><p><strong>进一步操作：</strong><br>针对上述端口，我将依次执行 <code>show running-config interface [端口名]</code> 命令…</p></blockquote><p><em>(AI随后自主地对 Gi2&#x2F;0&#x2F;5, Gi2&#x2F;0&#x2F;6, Gi2&#x2F;0&#x2F;7 分别执行了 <code>show running-config interface</code>，并将结果汇总如下)</em></p><blockquote><p><strong>汇总所有接口的详细运行配置如下：</strong></p><table><thead><tr><th>接口</th><th>配置详情</th></tr></thead><tbody><tr><td>GigabitEthernet2&#x2F;0&#x2F;5</td><td>- 工作模式: Access<br>- 访问 VLAN: 10<br>- 描述: 连接到销售部门工作站<br>- 启用端口快速生成树</td></tr><tr><td>GigabitEthernet2&#x2F;0&#x2F;6</td><td>- 工作模式: Access<br>- 访问 VLAN: 10<br>- 描述: 连接到市场部门工作站<br>- 启用端口快速生成树</td></tr><tr><td>GigabitEthernet2&#x2F;0&#x2F;7</td><td>- 工作模式: Access<br>- 访问 VLAN: 10<br>- 描述: 连接到广告部门工作站<br>- 启用端口快速生成树</td></tr></tbody></table><p><strong>分析与建议：</strong></p><ol><li><strong>接口配置一致性：</strong> 所有接口均配置为 Access 模式，并指向相同的 VLAN ID…</li><li><strong>生成树优化：</strong> 启用了 PortFast 功能，适用于直接连接终端设备的端口…</li><li><strong>安全性建议：</strong> 考虑在关键接口上启用 Port Security…</li></ol></blockquote><p><strong>点评:</strong> 这个案例完美展示了AI的逻辑推理和任务分解能力。它成功地将一个复杂的需求拆解为多个步骤，并且能够将第一步查询到的端口列表（Gi2&#x2F;0&#x2F;5-7）作为第二步查询的输入，最终将分散的信息整合成一份条理清晰的报告。这标志着AI已经从一个简单的命令执行器进化为了具备复杂任务处理能力的智能代理。</p><h3 id="3-3-自动化端到端故障诊断"><a href="#3-3-自动化端到端故障诊断" class="headerlink" title="3.3 自动化端到端故障诊断"></a>3.3 自动化端到端故障诊断</h3><p>这个最终考验模拟了一个最常见的运维场景，旨在检验AI作为智能代理的综合能力：自主规划、多步执行、关联分析并最终给出诊断结论。</p><p><strong>我的指令:</strong></p><blockquote><p>现在是最终考验。我收到一个报告，说连接在 <code>my-core-switch</code> 上的一台服务器失联了，它的MAC地址是 <code>0050.56a6.xxxx</code>。请你作为一名资深网络工程师，自主完成以下故障诊断流程并向我汇报。</p></blockquote><p><img src="/images/cisco3.png" alt="cisco3"></p><p>在向AI发出这个复杂的诊断指令后，其后台日志（如下图所示）为我们揭示了一个极其宝贵、也颇为有趣的细节，让我们得以一窥其工作的内在逻辑。</p><p>我们可以看到，AI并没有像传统脚本一样，一次性盲目地执行完所有预设命令。恰恰相反，它展现了一种严谨的、分步式的<strong>推理-行动-观察”（Reason-Act-Observe, ReAct）</strong> 工作循环。</p><ul><li><strong>第一步：它规划并执行了第一个动作</strong>——定位MAC地址。然后，它并没有立刻进行下一步，而是在日志中留下了一句类似“自言自语”的备注：<em>“请提供上述工具调用的结果，以便我继续完成后续的故障诊断步骤。”</em></li><li><strong>第二步：只有当它“观察”到了第一步的确切结果后</strong>（即MAC地址在Gi2&#x2F;0&#x2F;24上），它才基于这个<strong>新的事实</strong>，去规划并执行第二个动作——检查Gi2&#x2F;0&#x2F;24的接口状态。</li></ul><p><strong>这正是智能代理（Agent）与自动化脚本的根本区别：</strong></p><ul><li>脚本是<strong>预设路径</strong>的执行者，无论中途发生什么，它都会尝试走完所有流程。</li><li>而AI Agent是<strong>基于事实</strong>的决策者。它每一步的行动，都依赖于上一步的观察结果。如果第一步发现MAC地址在另一个端口，它后续的所有操作都会自动调整到那个正确的端口上。这种<strong>基于上下文的动态适应能力</strong>，是其能够处理复杂、未知问题的核心。</li></ul><p>因此，这段看似“卡住”的日志，实际上是AI在向我们展示其严谨的思考过程。它让我们不再将AI视为一个深不可测的“黑箱”，而是能够理解其决策逻辑、值得信赖的合作伙伴。</p><p><strong>AI的执行与分析报告:</strong><br><em>(AI自主地将任务分解为多个步骤，依次调用工具，并最终整合成了以下这份专业的诊断报告)</em></p><blockquote><h1 id="故障诊断报告"><a href="#故障诊断报告" class="headerlink" title="故障诊断报告"></a>故障诊断报告</h1><p><strong>日期时间</strong>: 2025&#x2F;7&#x2F;11 14:25:16<br><strong>操作人员</strong>: wiz<br><strong>设备</strong>: my-core-switch</p><p><strong>故障描述</strong>: 连接在 <strong>my-core-switch</strong> 上的一台服务器失联，其 MAC 地址为 <strong>0050.56a6.xxxx</strong>。</p><hr><h2 id="1-定位-MAC-地址所在的物理端口"><a href="#1-定位-MAC-地址所在的物理端口" class="headerlink" title="1. 定位 MAC 地址所在的物理端口"></a>1. 定位 MAC 地址所在的物理端口</h2><p><strong>执行命令</strong>: <code>show mac address-table | include 0050.56a6.xxxx</code><br><strong>发现</strong>: MAC 地址 <code>0050.56a6.xxxx</code> 位于端口 <strong>GigabitEthernet2&#x2F;0&#x2F;24</strong>，所属 VLAN 为 <strong>22</strong>。</p><hr><h2 id="2-检查端口-GigabitEthernet2-0-24-的接口状态和错误计数器"><a href="#2-检查端口-GigabitEthernet2-0-24-的接口状态和错误计数器" class="headerlink" title="2. 检查端口 GigabitEthernet2&#x2F;0&#x2F;24 的接口状态和错误计数器"></a>2. 检查端口 GigabitEthernet2&#x2F;0&#x2F;24 的接口状态和错误计数器</h2><p><strong>执行命令</strong>: <code>show interface GigabitEthernet2/0/24</code><br><strong>发现</strong>: 接口状态为 <strong>up&#x2F;up (connected)</strong>，输入&#x2F;输出错误计数器均为 <strong>0</strong>。物理层和数据链路层连接正常。</p><hr><h2 id="3-检查VLAN-22的三层接口（SVI）是否正常工作"><a href="#3-检查VLAN-22的三层接口（SVI）是否正常工作" class="headerlink" title="3. 检查VLAN 22的三层接口（SVI）是否正常工作"></a>3. 检查VLAN 22的三层接口（SVI）是否正常工作</h2><p><strong>执行命令</strong>: <code>show interface vlan22</code><br><strong>发现</strong>: <strong>Vlan22</strong> 的三层接口状态为 <strong>up&#x2F;up</strong>，IP地址配置为 <code>192.168.22.xxx/xx</code>，运行正常。</p><hr><h2 id="4-最终诊断结论"><a href="#4-最终诊断结论" class="headerlink" title="4. 最终诊断结论"></a>4. 最终诊断结论</h2><p>经过详细的故障诊断，<strong>my-core-switch</strong> 上的端口 <strong>Gi2&#x2F;0&#x2F;24</strong> 和对应的 <strong>Vlan22</strong> 三层接口均运行正常，未检测到交换机层面的错误。因此，服务器失联的问题<strong>极大概率并非由本交换机引起</strong>。</p><p><strong>可能的根本原因指向</strong>:</p><ul><li><strong>服务器本身</strong>: 操作系统故障、网卡驱动问题或网络配置错误。</li><li><strong>IP 地址冲突</strong>: 服务器的IP地址可能与网络中其他设备冲突。</li><li><strong>上游&#x2F;下游网络策略</strong>: 可能存在防火墙或路由器的ACL策略阻止了服务器的通信。</li></ul><p><strong>建议的下一步排查步骤</strong>:</p><ol><li><strong>检查服务器状态</strong>: 确认服务器系统、服务及网络配置（IP、网关、DNS）。</li><li><strong>验证IP地址冲突</strong>: 在交换机上使用 <code>show arp | include [服务器IP]</code> 检查ARP映射。</li><li><strong>测试端到端连通性</strong>: 从同一VLAN内的其他设备Ping服务器，以及从服务器Ping其网关(<code>192.168.22.xxx</code>)。</li><li><strong>物理介质检查</strong>: 考虑更换网线或服务器网卡。<br>…</li></ol></blockquote><p><strong>点评:</strong> 这份报告完美展现了AIOps的巅峰潜力。AI不仅像一个真人专家一样，有条不紊地完成了所有排查步骤，更重要的是，在排除了自身管辖范围内的故障后，它没有止步，而是给出了逻辑严谨的诊断结论和一份极其专业、可执行的跨领域排查指南。这标志着它已经从一个“网络运维工具”进化为了一个具备全局视野的“<strong>智能故障协调中心</strong>”。</p><h3 id="3-4-复杂任务下的深度思考能力对决"><a href="#3-4-复杂任务下的深度思考能力对决" class="headerlink" title="3.4 复杂任务下的深度思考能力对决"></a>3.4 复杂任务下的深度思考能力对决</h3><p>为了进一步探究不同AI模型在复杂、多步任务下的表现差异，我们设计了一项综合性更强的“系统健康检查”任务，并将其同时交给了我们之前使用的O1-mini模型和另一款国产AI模型DeepSeek-R1。这项任务要求AI自主执行四项关联性不高的检查，并汇总成一份报告，旨在考验其任务规划、并行处理和深度分析能力。</p><p><strong>我的指令:</strong></p><blockquote><p>请对 <code>my-core-switch</code> 进行一次全面的系统健康检查。我需要你检查并汇总以下四个方面的情况，并给我一个最终的摘要报告：</p><ol><li>CPU利用率（过去5分钟）。</li><li>内存使用情况（Processor和I&#x2F;O内存）。</li><li>所有物理接口的错误计数器总和。</li><li>最新的10条日志信息。</li></ol></blockquote><h4 id="O1-mini-的表现：机械化的串行执行者"><a href="#O1-mini-的表现：机械化的串行执行者" class="headerlink" title="O1-mini 的表现：机械化的串行执行者"></a>O1-mini 的表现：机械化的串行执行者</h4><p>O1-mini模型在处理这个任务时，表现得像一个线性的自动化脚本。它开始执行第一个CPU检查任务，并成功返回了结果。然而，在执行第二个“内存检查”任务时，由于<code>show memory</code>命令返回内容过多导致工具超时，它报告了一个连接错误。</p><p><strong>致命缺陷：</strong> 在遇到这一个子任务的失败后，O1-mini<strong>中止了整个健康检查流程</strong>，直接放弃了后续的“接口错误检查”和“日志检查”。最终，它只完成了一份25%进度的、残缺的报告，并将所有问题归咎于一个它未能深入分析的“连接错误”。</p><p><img src="/images/O1%E6%83%9C%E8%B4%A5.png" alt="o1没能胜任"></p><p><strong>结论：</strong> O1-mini能够机械化地完成基础、独立的任务。也具备一定的反复试错的能力，但面对复杂的、多步骤的综合性任务时，它的处理逻辑是脆弱的、串行的。任何一个环节的失败都会导致整个任务链的中断，缺乏应对复杂现实世界问题的鲁棒性。</p><h4 id="DeepSeek-R1-的表现：具备深度思考的智能分析师"><a href="#DeepSeek-R1-的表现：具备深度思考的智能分析师" class="headerlink" title="DeepSeek-R1 的表现：具备深度思考的智能分析师"></a>DeepSeek-R1 的表现：具备深度思考的智能分析师</h4><p>与O1-mini形成鲜明对比的是，DeepSeek-R1展现出了惊人的智能和深度。它似乎在内部将四项检查分解为独立的子任务，并成功地完成了所有指令，即使遇到问题也会不断地反复去试错，虽然完成时间上因为长思考的原因会更久，但最终能呈现一份堪称典范的健康报告。</p><p><strong>DeepSeek-R1的诊断报告摘要:</strong></p><blockquote><h3 id="系统健康检查报告：my-core-switch"><a href="#系统健康检查报告：my-core-switch" class="headerlink" title="系统健康检查报告：my-core-switch"></a>系统健康检查报告：my-core-switch</h3><h4 id="1-CPU利用率（过去5分钟）"><a href="#1-CPU利用率（过去5分钟）" class="headerlink" title="1. CPU利用率（过去5分钟）"></a>1. CPU利用率（过去5分钟）</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">| 时间范围      | 利用率 | 状态评估 |</span><br><span class="line">|---------------|--------|----------|</span><br><span class="line">| 5分钟平均     | 4%     | 低负载   |</span><br></pre></td></tr></table></figure><p><strong>分析</strong>：CPU利用率处于健康范围，控制平面处理能力充足。</p><h4 id="2-内存使用情况"><a href="#2-内存使用情况" class="headerlink" title="2. 内存使用情况"></a>2. 内存使用情况</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">| 内存类型      | 使用率 |</span><br><span class="line">|---------------|--------|</span><br><span class="line">| Processor     | 9.67%  |</span><br><span class="line">| I/O           | 0.69%  |</span><br></pre></td></tr></table></figure><p><strong>分析</strong>：内存使用率极低，无内存压力。</p><h4 id="3-物理接口错误计数器"><a href="#3-物理接口错误计数器" class="headerlink" title="3. 物理接口错误计数器"></a>3. 物理接口错误计数器</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">| 错误类型         | 总计数 |</span><br><span class="line">|------------------|--------|</span><br><span class="line">| 输入错误         | 0      |</span><br><span class="line">| 输出错误         | 0      |</span><br><span class="line">| ... (所有错误均为0) ...|</span><br></pre></td></tr></table></figure><p><strong>分析</strong>：全接口错误计数器为零，表明物理层与数据链路层无传输错误。</p><h4 id="4-最新10条系统日志"><a href="#4-最新10条系统日志" class="headerlink" title="4. 最新10条系统日志"></a>4. 最新10条系统日志</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">2. Jun 12 10:23:46.456: %LINEPROTO-5-UPDOWN: Line protocol on Interface GigabitEthernet0/3, changed state to down</span><br><span class="line">...</span><br><span class="line">9. Jun 12 10:45:40.666: %LINK-5-CHANGED: Interface GigabitEthernet0/1, changed state to administratively down</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p><strong>关键日志分析</strong>：</p><ol><li>G0&#x2F;3接口持续存在协议层故障。</li><li>G0&#x2F;1接口被管理关闭。</li></ol><hr><h3 id="最终健康评估摘要"><a href="#最终健康评估摘要" class="headerlink" title="最终健康评估摘要"></a>最终健康评估摘要</h3><table><thead><tr><th>检查项</th><th>状态</th><th>风险等级</th><th>建议</th></tr></thead><tbody><tr><td>CPU负载</td><td>正常</td><td>低</td><td>无需干预</td></tr><tr><td>内存使用</td><td>优秀</td><td>无风险</td><td>持续监控</td></tr><tr><td>接口错误</td><td>完美</td><td>无风险</td><td>保持当前状态</td></tr><tr><td>日志事件</td><td><strong>注意</strong></td><td><strong>中</strong></td><td><strong>需处理G0&#x2F;3协议故障</strong></td></tr></tbody></table><p><strong>综合结论</strong>：<br>设备整体健康状态<strong>优秀</strong>，但需重点关注G0&#x2F;3接口的协议层故障。</p><p><strong>建议行动</strong>：</p><ol><li>立即解决G0&#x2F;3协商问题（强制速率&#x2F;双工）。</li><li>确认G0&#x2F;1关闭是否属于计划维护。</li></ol></blockquote><p><strong>点评：</strong> 这份报告的含金量极高。DeepSeek-R1不仅完整地执行了所有任务，更展现了几个关键的“智能”特质：</p><ol><li><strong>数据聚合与定性分析</strong>：它没有罗列枯燥的数字，而是给出了“低负载”、“优秀”等定性判断。</li><li><strong>上下文关联</strong>：它能从最新的日志中，关联到我们之前排查过的G0&#x2F;3端口问题，显示了强大的上下文记忆和分析能力。</li><li><strong>风险评估与决策</strong>：最终的“摘要”表格一目了然地指出了风险等级，并给出了具体、可行的“建议行动”，这已经超越了“报告”，进入了“决策支持”的范畴。</li></ol><p><img src="/images/deepseek%E5%8F%8D%E5%A4%8D.png" alt="deepseek在烧烤"><br><img src="/images/deepseek%E7%BB%93%E6%9E%9C.png" alt="deepseek结果"></p><p><strong>对决结论：</strong><br>通过这次对比，我们可以得出一个清晰的结论：在处理需要<strong>深度思考、多步推理和综合判断的复杂问题</strong>时，以<strong>DeepSeek-R1为代表的国产AI</strong>展现出了远超普通模型的强大能力。它不再是一个简单的任务执行工具，而更像一个能够独立思考、规划并解决问题的“AI专家”。而O1-mini等模型，在现阶段则更适合执行明确、单一的基础自动化任务。这也为我们未来的AIOps实践指明了方向：选择合适的AI模型，是决定项目成败和智能深度的关键所在。</p><h2 id="四、未来方向：MCP的星辰大海"><a href="#四、未来方向：MCP的星辰大海" class="headerlink" title="四、未来方向：MCP的星辰大海"></a>四、未来方向：MCP的星辰大海</h2><p>本次实践成功地将AI转变为一个Cisco网络专家，但这仅仅是冰山一角。MCP协议与大模型的结合，正为AIOps开启一扇通往未来的大门。</p><ol><li><p><strong>从“被动响应”到“主动防御”：意图驱动的AIOps</strong><br>未来的MCP服务将不再仅仅是执行命令的工具。我们可以构建一个“网络意图MCP服务”。运维人员不再说“把G1&#x2F;0&#x2F;5端口划入VLAN 10”，而是陈述最终意图：“<strong>确保新来的市场部员工PC能访问内网文件服务器和外网</strong>”。AI会自己去规划需要配置哪个交换机、哪个端口、哪个VLAN、哪条ACL，生成完整的配置脚本，并在“沙箱”中验证无误后，待审批执行。这是一种更高维度的自动化。</p></li><li><p><strong>融合多模态：迈向真正的“数字孪生”</strong><br>正如马斯克的Grok-4所展示的趋势，未来的模型将是多模态的。我们的<code>cisco-mcp</code>可以与<code>fortigate-mcp</code>（用于绘制拓扑图）等服务进行<strong>联动</strong>。当诊断故障时，AI不仅能返回文本报告，还能<strong>实时地在高亮显示故障路径的网络拓扑图上进行标注</strong>，甚至结合摄像头的视频流（例如机房摄像头MCP）来判断“端口灯不亮”这种物理问题。这使得运维从“看命令行”进化到“看数字孪生驾驶舱”。</p></li><li><p><strong>AI Agent集群与分布式决策</strong><br>我们可以为网络、服务器、数据库、应用程序各部署一个专精的AI Agent（MCP服务）。当出现“应用访问缓慢”这种复杂问题时，应用AI会首先自检，然后向网络AI发出请求：“请检查从我到数据库服务器<code>10.1.1.5</code>的网络延迟和丢包率”。网络AI完成检查后，可能会再向服务器AI发出请求：“请检查<code>10.1.1.5</code>的CPU和磁盘I&#x2F;O”。这些AI Agent组成一个<strong>分布式的智能诊断集群</strong>，通过MCP协议互相协作，在数秒内完成跨多个技术领域的复杂故障定位，这是任何单一的人类专家都难以企及的效率。</p></li></ol><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>从一个简单的<code>show version</code>命令，到一个全自动的故障诊断报告，我们见证了MCP协议与高阶提示词工程相结合所爆发出的巨大能量。AIOps不再是遥远的概念，它正通过像<code>cisco-mcp</code>这样的实践，具体而微地改变着我们的工作方式。未来已来，而我们每个人，都有机会成为这场智能变革的构建者。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;基于前一次的实践，这次的cisco交换机ai也能绘制出以交换机为中心的网络拓扑图！&lt;/p&gt;</summary>
    
    
    
    <category term="技术实践" scheme="https://grokfree.xyz/categories/%E6%8A%80%E6%9C%AF%E5%AE%9E%E8%B7%B5/"/>
    
    <category term="AIOps" scheme="https://grokfree.xyz/categories/%E6%8A%80%E6%9C%AF%E5%AE%9E%E8%B7%B5/AIOps/"/>
    
    
    <category term="AI" scheme="https://grokfree.xyz/tags/AI/"/>
    
    <category term="AIOps" scheme="https://grokfree.xyz/tags/AIOps/"/>
    
    <category term="网络运维" scheme="https://grokfree.xyz/tags/%E7%BD%91%E7%BB%9C%E8%BF%90%E7%BB%B4/"/>
    
    <category term="Cisco" scheme="https://grokfree.xyz/tags/Cisco/"/>
    
    <category term="LLM" scheme="https://grokfree.xyz/tags/LLM/"/>
    
    <category term="提示词工程" scheme="https://grokfree.xyz/tags/%E6%8F%90%E7%A4%BA%E8%AF%8D%E5%B7%A5%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>只要5秒？AI画出整个公司网络！这不再是科幻！</title>
    <link href="https://grokfree.xyz/2025/07/10/ssh%E9%98%B2%E7%81%AB%E5%A2%99mcp/"/>
    <id>https://grokfree.xyz/2025/07/10/ssh%E9%98%B2%E7%81%AB%E5%A2%99mcp/</id>
    <published>2025-07-10T02:00:00.000Z</published>
    <updated>2025-07-14T01:51:03.159Z</updated>
    
    <content type="html"><![CDATA[<p>基于MCP协议的AIOps实践：大语言模型与FortiGate防火墙的深度整合</p><p>随着大语言模型（LLM）在各个领域的渗透，将其强大的认知与推理能力应用于传统的网络运维（NetOps）领域，即 AIOps，已成为业界探索的前沿方向。</p><span id="more"></span><p>本文将提供一份详尽的技术实践报告，记录如何利用模型上下文协议（Model Context Protocol, MCP），将本地部署的 AI 模型（以 O1-mini 为例）与一台 FortiGate 防火墙通过 SSH 进行整合，从而实现从自然语言指令到精确网络操作的端到端自动化。</p><h2 id="只要5秒？AI画出整个公司网络！这不再是科幻！"><a href="#只要5秒？AI画出整个公司网络！这不再是科幻！" class="headerlink" title="只要5秒？AI画出整个公司网络！这不再是科幻！"></a>只要5秒？AI画出整个公司网络！这不再是科幻！</h2><p>告别逐行敲打<code>show</code>命令与手动绘图的低效时代。现在，只需一句自然语言指令，大模型便能深入设备，将错综复杂的网络配置瞬间转化为一张清晰直观的可视化拓扑图。</p><p>下图，便是AI的杰作。请看它如何一眼看穿我们的网络世界。</p><p><img src="/images/%E9%98%B2%E7%81%AB%E5%A2%99%E4%B8%8B%E7%9A%84%E7%BD%91%E7%BB%9C%E6%8B%93%E6%89%91%E5%9B%BE.png" alt="防火墙下的网络拓扑图"></p><p>图注: 此拓扑图由 AI 分析 FortiGate 的接口配置、路由表和防火墙策略后自动生成。</p><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ol><li><a href="#1-mcp%E5%8D%8F%E8%AE%AE%E8%BF%9E%E6%8E%A5ai%E6%99%BA%E8%83%BD%E4%B8%8E%E7%89%A9%E7%90%86%E4%B8%96%E7%95%8C%E7%9A%84%E6%A1%A5%E6%A2%81">MCP协议：连接AI智能与物理世界的桥梁</a></li><li><a href="#2-mcp%E7%94%9F%E6%80%81%E8%B5%84%E6%BA%90">MCP生态资源</a></li><li><a href="#3-ssh-mcp%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%83%A8%E7%BD%B2%E5%AE%9E%E8%B7%B5-vilasone455ssh-mcp-server">SSH MCP服务器部署</a></li><li><a href="#4-%E6%8F%90%E7%A4%BA%E8%AF%8D%E5%B7%A5%E7%A8%8B%E4%B8%8E%E6%A8%A1%E5%9E%8B%E8%B0%83%E4%BC%98%E9%93%B8%E5%B0%B1%E4%BD%A0%E7%9A%84ai%E9%98%B2%E7%81%AB%E5%A2%99%E4%B8%93%E5%AE%B6">提示词工程与模型调优</a></li><li><a href="#5-%E6%88%90%E6%9E%9C%E5%B1%95%E7%A4%BAai%E9%A9%B1%E5%8A%A8%E7%9A%84fortigate%E9%98%B2%E7%81%AB%E5%A2%99%E7%AE%A1%E7%90%86">成果展示</a></li></ol><h2 id="1-MCP协议：连接AI智能与物理世界的桥梁"><a href="#1-MCP协议：连接AI智能与物理世界的桥梁" class="headerlink" title="1. MCP协议：连接AI智能与物理世界的桥梁"></a>1. MCP协议：连接AI智能与物理世界的桥梁</h2><p>模型上下文协议（MCP）是一种为解决大语言模型与外部世界交互而设计的开放标准。其核心价值在于定义了一套统一的规范，使得 AI 模型能够发现、理解并调用外部的”工具”（Tools）。这些工具可以是任何形式的 API、本地脚本或硬件接口。</p><p>在网络运维场景下，MCP 的作用尤为关键：</p><ul><li><strong>指令解析</strong>: 将运维人员的自然语言需求（如”检查内网到外网的策略”）转换为结构化的工具调用请求。</li><li><strong>任务执行</strong>: 触发本地的 MCP 服务器执行具体操作（如通过 SSH 连接防火墙并运行命令）。</li><li><strong>结果反馈</strong>: 读取工具返回的原始 CLI 输出，并将其传递给 AI 模型，供其分析、总结并以人类可读的形式呈现。</li></ul><blockquote><p>MCP 协议生态的成熟，是推动 AIOps 从概念走向实践的关键一步，它为实现真正智能的、可交互的网络自动化提供了基础。</p></blockquote><h2 id="2-MCP生态资源"><a href="#2-MCP生态资源" class="headerlink" title="2. MCP生态资源"></a>2. MCP生态资源</h2><p>在深入实践之前，了解当前 MCP 的生态系统有助于发现更多可能性。以下资源提供了丰富的工具和平台：</p><ul><li><a href="https://mcp.higress.ai/">MCP Hub (higress.ai)</a> - 一个社区驱动的 MCP 工具注册中心。</li><li><a href="https://mcp.so/">MCP.so</a> - 提供 MCP 相关协议文档和工具示例。</li><li><a href="https://github.com/topics/mcp">GitHub</a> - 在 GitHub 上通过 mcp 标签可以找到大量相关的开源项目和工具。</li></ul><h2 id="3-SSH-MCP服务器部署：实践ssh-mcp-server"><a href="#3-SSH-MCP服务器部署：实践ssh-mcp-server" class="headerlink" title="3. SSH MCP服务器部署：实践ssh-mcp-server"></a>3. SSH MCP服务器部署：实践ssh-mcp-server</h2><p>本次实践，我选用了一个提供通用 SSH 控制能力的开源 MCP 服务器项目：<a href="https://github.com/vilasone455/ssh-mcp-server">vilasone455&#x2F;ssh-mcp-server</a>。该项目旨在使 LLM 能够通过 SSH 安全地执行 Shell 命令。尽管其 README 提及的是 Linux 和 Windows 系统，但其底层 SSH 协议的通用性使其完全适用于 FortiGate 防火墙等网络设备。</p><h3 id="3-1-部署安装过程中的挑战与解决"><a href="#3-1-部署安装过程中的挑战与解决" class="headerlink" title="3.1 部署安装过程中的挑战与解决"></a>3.1 部署安装过程中的挑战与解决</h3><p>按照项目 README 的指引，我开始了标准的安装流程：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 克隆项目仓库</span></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/vilasone455/ssh-mcp-server.git</span><br><span class="line"><span class="built_in">cd</span> ssh-mcp-server</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装项目依赖</span></span><br><span class="line">npm install</span><br><span class="line"></span><br><span class="line"><span class="comment"># 构建项目</span></span><br><span class="line">npm run build</span><br></pre></td></tr></table></figure><p>然而，在执行 <code>npm run build</code> 时，我遇到了一个编译错误：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">src/index.ts:422:19 - error TS2339: Property &#x27;trim&#x27; does not exist on type &#x27;unknown&#x27;.</span><br><span class="line">422 if (!command?.trim()) throw new Error(&quot;Command cannot be empty.&quot;);</span><br></pre></td></tr></table></figure><p><strong>问题分析</strong>：这是一个 TypeScript 编译时错误，编译器无法确认 command 变量的类型是字符串，因此不允许调用 trim() 方法。</p><p><strong>解决方案</strong>：我通过在代码中添加一个类型断言，明确告诉编译器 command 是一个字符串。</p><p><strong>操作步骤</strong>：</p><ol><li>用文本编辑器打开 <code>C:\xxx\xxx\ssh-mcp-server\src\index.ts</code> 文件</li><li>定位到第 422 行</li><li>将原代码 <code>if (!command?.trim()) throw new Error(&quot;Command cannot be empty.&quot;);</code></li><li>修改为 <code>if (!(command as string)?.trim()) throw new Error(&quot;Command cannot be empty.&quot;);</code></li><li>保存文件</li></ol><p>修复此问题后，再次执行 <code>npm run build</code>，项目成功编译，生成了 dist 目录。</p><h3 id="3-2-配置-machines-json：定义你的防火墙"><a href="#3-2-配置-machines-json：定义你的防火墙" class="headerlink" title="3.2 配置 machines.json：定义你的防火墙"></a>3.2 配置 machines.json：定义你的防火墙</h3><p>ssh-mcp-server 通过 <code>machines.json</code> 文件来管理所有可连接的设备信息。我们需要创建这个文件并填入 FortiGate 防火墙的连接凭据。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">[</span></span><br><span class="line">  <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;machine_id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;mypc&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;label&quot;</span><span class="punctuation">:</span> <span class="string">&quot;My FortiGate Firewall&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;os&quot;</span><span class="punctuation">:</span> <span class="string">&quot;fortios&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;source&quot;</span><span class="punctuation">:</span> <span class="string">&quot;network-segment&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;ssh&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;host&quot;</span><span class="punctuation">:</span> <span class="string">&quot;192.168.x.x&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;port&quot;</span><span class="punctuation">:</span> <span class="number">22</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;username&quot;</span><span class="punctuation">:</span> <span class="string">&quot;your_fortigate_username&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;password&quot;</span><span class="punctuation">:</span> <span class="string">&quot;your_fortigate_password&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span></span><br></pre></td></tr></table></figure><ul><li><code>machine_id</code>: 这是一个唯一的字符串，作为 AI 识别设备的”代号”。例如 Fortigate</li><li><code>host</code>: FortiGate 防火墙的 IP 地址</li><li><code>username</code>: 登录 FortiGate 的 SSH 用户名</li><li><code>password</code>: 登录密码</li></ul><h3 id="3-3-在-Cherry-Studio-中注册-MCP-服务器"><a href="#3-3-在-Cherry-Studio-中注册-MCP-服务器" class="headerlink" title="3.3 在 Cherry Studio 中注册 MCP 服务器"></a>3.3 在 Cherry Studio 中注册 MCP 服务器</h3><p>最后一步是将 ssh-mcp-server 注册到 Cherry Studio，使其能够被 AI 模型调用。</p><p><strong>配置参数</strong>：</p><ul><li><strong>名称 (Name)</strong>: ssh-mcp-server</li><li><strong>类型 (Type)</strong>: 标准输入输出 (stdio)</li><li><strong>命令 (Command)</strong>: node</li><li><strong>参数 (Arguments)</strong>: <code>C:/xxx/xxx/ssh-mcp-server/dist/index.js</code></li><li><strong>环境变量 (Environment Variables)</strong>: <code>MACHINES_PATH=C:/xxx/xxx/ssh-mcp-server/machines.json</code></li><li><strong>超时 (Timeout)</strong>: 180 (秒)</li></ul><p>![ssh mcp部署](&#x2F;images&#x2F;ssh mcp部署.png)</p><h2 id="4-提示词工程与模型调优：铸就你的AI防火墙专家"><a href="#4-提示词工程与模型调优：铸就你的AI防火墙专家" class="headerlink" title="4. 提示词工程与模型调优：铸就你的AI防火墙专家"></a>4. 提示词工程与模型调优：铸就你的AI防火墙专家</h2><p>工具部署成功只是开始。如果没有经过精心设计的提示词和严格的参数控制，大语言模型在专业领域的表现往往是不可靠甚至危险的。<strong>在本次实践的初期，我们尝试使用通用提示词，结果发现 AI 的行为非常不稳定，时常误解指令，甚至在面对不确定的情况时，会“创造”出虚假的配置信息，这在生产环境中是绝对无法接受的。</strong></p><p>正是通过下面一系列精细化的提示词工程与模型参数调优，我们才成功地将一个“充满想象力”的通用模型，改造为了一个“严谨、精确、可靠”的AI防火墙专家。</p><h3 id="4-1-模型选择与参数设置"><a href="#4-1-模型选择与参数设置" class="headerlink" title="4.1 模型选择与参数设置"></a>4.1 模型选择与参数设置</h3><p>我选用 O1-mini 模型，并对其参数进行了关键调整：</p><table><thead><tr><th>参数</th><th>设置值</th><th>作用</th></tr></thead><tbody><tr><td>模型温度 (Temperature)</td><td>0</td><td>将模型的创造性降至最低，强制其生成最确定、最符合事实的回答</td></tr><tr><td>Top-p</td><td>0.05</td><td>收窄模型词汇选择范围，确保回答的高度一致性和精确性</td></tr><tr><td>上下文数 (Context Length)</td><td>15</td><td>确保 AI 在复杂场景下不会”失忆”，能记住之前的命令和结果</td></tr></tbody></table><p><img src="/images/AI%E6%A8%A1%E5%9E%8B%E8%AE%BE%E7%BD%AE.png" alt="AI模型设置"></p><p><strong>将“模型温度”与“Top-p”设置为极低值，是抑制模型“幻觉”现象的关键所在。</strong> 这种配置强制模型在生成回答时，几乎完全依赖于从工具（即防火墙CLI）返回的真实上下文，而不是基于其内部知识库进行创造性联想。如果AI在防火墙上没有查询到信息，它会如实报告“未找到”，而不会为了“完成任务”而编造一个看似合理的答案。这确保了所有输出的高度事实性和可靠性。</p><h3 id="4-2-系统级基础提示词"><a href="#4-2-系统级基础提示词" class="headerlink" title="4.2 系统级基础提示词"></a>4.2 系统级基础提示词</h3><p>为 AI 设定一个明确、专业的行为框架至关重要。我编写了一份系统级的”基础提示词”，作为每次对话的”宪法”。</p><p><img src="/images/AI%E6%8F%90%E7%A4%BA%E8%AF%8D%E8%AE%BE%E7%BD%AE.png" alt="AI提示词设置"></p><blockquote><p><strong>注意</strong>：提示词中需要提醒大模型你拥有<strong>只读</strong>权限，无法修改实际内容，防止对防火墙内容进行破坏。本连接目前只推荐用来获取信息与分析。</p></blockquote><h3 id="4-3-应对长输出：分段扫描与处理策略"><a href="#4-3-应对长输出：分段扫描与处理策略" class="headerlink" title="4.3 应对长输出：分段扫描与处理策略"></a>4.3 应对长输出：分段扫描与处理策略</h3><p>在与网络设备交互时，一个常见的挑战是处理长命令输出，例如 <code>show full-configuration</code> 或 <code>get router info routing-table all</code>。这类命令的返回内容往往会因为终端屏幕的限制而被分页，显示 <code>--More--</code> 提示符，等待用户输入（如空格键）才能继续显示。</p><p>如果让 AI 一次性拉取全部内容，不仅容易导致超时，还可能因为缓冲区溢出而使整个任务失败。为了解决这个问题，我们设计了一套<strong>分段扫描策略</strong>：</p><ol><li><strong>识别分页符</strong>：在提示词中明确指示 AI，当它在命令输出的末尾看到 <code>--More--</code> 标志时，应暂停执行。</li><li><strong>分块处理</strong>：AI 会先将当前收到的部分数据进行分析和整理。</li><li><strong>发送继续指令</strong>：处理完当前数据块后，AI 会主动发起一个新的工具调用，其命令就是一个“发送空指令”（等效于敲击空格键），以获取下一页的内容。</li><li><strong>循环直至结束</strong>：重复步骤1-3，直到命令输出不再出现 <code>--More--</code> 标志，代表所有内容已获取完毕。</li></ol><p>通过这种“走走停停”的分段处理方式，AI 能够稳定、可靠地处理任意长度的配置信息，避免了因单次数据量过大而导致的程序崩溃，大大增强了方案的稳定性。</p><h2 id="5-成果展示：AI驱动的FortiGate防火墙管理"><a href="#5-成果展示：AI驱动的FortiGate防火墙管理" class="headerlink" title="5. 成果展示：AI驱动的FortiGate防火墙管理"></a>5. 成果展示：AI驱动的FortiGate防火墙管理</h2><p>经过上述所有配置和调优，我的 AI 助手已经能够稳定、准确地执行任务。以下是一些真实的交互案例：</p><h3 id="5-1-基础信息获取与命令执行验证"><a href="#5-1-基础信息获取与命令执行验证" class="headerlink" title="5.1 基础信息获取与命令执行验证"></a>5.1 基础信息获取与命令执行验证</h3><p><strong>我的提问</strong>:</p><blockquote><p>“好的，我们开始。请在 Fortigate 上执行 get system status 命令，让我看看防火墙的系统信息。”</p></blockquote><p><strong>AI 执行与返回</strong>:<br>AI 成功连接并执行命令。尽管首次连接尝试中出现了”无法找到连接 ID”的短暂错误，但 AI 随即进行了自我修正，成功创建了连接并执行了命令。</p><p><img src="/images/%E6%9F%A5%E7%9C%8B%E9%98%B2%E7%81%AB%E5%A2%99%E5%9F%BA%E7%A1%80%E4%BF%A1%E6%81%AF1.png" alt="查看防火墙基础信息1"></p><p>AI 返回了防火墙的型号、固件版本、序列号、正常运行时间等关键信息，并进行了专业的结构化总结与分析。</p><p><img src="/images/%E9%98%B2%E7%81%AB%E5%A2%99%E4%BF%A1%E6%81%AF%E5%8E%9F%E5%A7%8B%E8%BE%93%E5%87%BA.png" alt="防火墙信息原始输出"><br><img src="/images/%E9%98%B2%E7%81%AB%E5%A2%99%E4%BF%A1%E6%81%AF%E7%9A%84%E7%BB%93%E6%9E%84%E5%8C%96%E6%80%BB%E7%BB%93.png" alt="防火墙信息的结构化总结"><br><img src="/images/%E5%88%86%E6%9E%90%E4%B8%8E%E5%BB%BA%E8%AE%AE.png" alt="分析与建议"></p><h3 id="5-2-精确的地址对象查询与专业分析"><a href="#5-2-精确的地址对象查询与专业分析" class="headerlink" title="5.2 精确的地址对象查询与专业分析"></a>5.2 精确的地址对象查询与专业分析</h3><p><strong>任务</strong>: 查询地址对象 wz-office 的详细信息。</p><p><strong>我的提问</strong>:</p><blockquote><p>“请在 Fortigate 上，精确地查询并显示地址对象 wz-office 的详细配置。不要使用 grep，直接查询这个对象。”</p></blockquote><p><strong>AI 执行与返回</strong>:<br>AI 成功执行 <code>show firewall address wz-office</code>，返回了与我手动查询完全一致的真实数据。更重要的是，它对结果进行了专业解读，包括子网换算和实际 IP 范围分析。</p><p><img src="/images/office%E7%9A%84%E7%9B%B4%E6%8E%A5%E6%9F%A5%E8%AF%A2.png" alt="office的直接查询"></p><h3 id="5-3-深度安全策略审计与风险识别"><a href="#5-3-深度安全策略审计与风险识别" class="headerlink" title="5.3 深度安全策略审计与风险识别"></a>5.3 深度安全策略审计与风险识别</h3><p><strong>任务</strong>: 检查 wz-office 在防火墙策略中的应用情况，并识别潜在安全风险。</p><p><strong>我的提问</strong>:</p><blockquote><p>“请检查 Fortigate 上所有引用了 wz-office 地址对象的防火墙策略。同时，请检查其所在的地址组，并对可能存在的安全风险进行评估。”</p></blockquote><p><strong>AI 执行与返回</strong>:<br>AI 智能地规划了多步操作，包括查询策略和地址组，并主动指出了其中的安全风险，提供了优化建议。</p><p><img src="/images/%E7%AD%96%E7%95%A5%E5%8F%8D%E9%A6%88.png" alt="策略反馈"><br><img src="/images/%E5%AE%89%E5%85%A8%E9%A3%8E%E9%99%A9%E8%AF%84%E4%BC%B0.png" alt="安全风险评估"></p><h3 id="5-4-复杂数据提取与结构化呈现"><a href="#5-4-复杂数据提取与结构化呈现" class="headerlink" title="5.4 复杂数据提取与结构化呈现"></a>5.4 复杂数据提取与结构化呈现</h3><p><strong>任务</strong>: 获取路由表信息并整理成表格。</p><p><strong>我的提问</strong>:</p><blockquote><p>“请获取 Fortigate 的完整路由表信息。我需要你将输出的所有路由条目，无论类型是静态（S）、直连（C）还是其他，都整理成一个表格，包含目的网络、子网掩码、下一跳网关和出接口。”</p></blockquote><p><strong>AI 执行与返回</strong>:<br>AI 成功执行 <code>get router info routing-table all</code>，并准确地从复杂的原始输出中解析出所有类型（包括 S 和 C）的路由条目，然后以清晰的表格形式呈现。</p><p><img src="/images/%E8%B7%AF%E7%94%B1%E8%A1%A8.png" alt="路由表"></p><h3 id="5-5-自主生成多层网络架构图"><a href="#5-5-自主生成多层网络架构图" class="headerlink" title="5.5 自主生成多层网络架构图"></a>5.5 自主生成多层网络架构图</h3><p>在验证了AI精确执行和结构化呈现的能力后，我们决定发起一项终极挑战，测试其综合分析与高级生成的能力——让它从零开始，绘制一张详尽的网络架构图。这不再是简单的数据提取，而是对网络关系的深度理解和可视化重构。</p><p><strong>我的提问</strong>:</p><blockquote><p>“做得非常好。现在是最后的任务，我需要你展示你的综合分析能力。请连接到 Fortigate，深度扫描其接口配置、路由表、VLAN设置以及ARP缓存信息，推断出整体网络架构。然后，为我生成一份详细的、多层级的网络拓扑图的 Mermaid 代码。这张图必须清晰地划分出公网、DMZ区、核心网络、服务器区和无线接入区，并尽可能标注关键设备的型号、IP地址和VLAN信息。”</p></blockquote><p><strong>AI 执行与返回</strong>:<br>收到指令后，AI展现了其作为“智能代理”的真正价值。它没有等待我给出具体命令，而是自主规划并执行了一系列关联操作：</p><ol><li><strong>边界探测</strong>: 执行 <code>get system interface</code>，识别出 <code>wan1</code> 口作为公网出口，并找到 <code>dmz</code> 接口。</li><li><strong>核心分析</strong>: 通过 <code>get router info routing-table all</code> 和 <code>show system switch-interface</code>，定位到连接内网核心交换机的 <code>lan</code> 口，并识别出其承载的多个VLAN。</li><li><strong>下游推断</strong>: 结合 <code>get system arp</code> 的输出，AI发现了核心交换机、WLC（无线控制器）、服务器宿主机等关键设备的IP和MAC地址，并根据IP段将其归入对应的VLAN和逻辑区域。</li><li><strong>信息整合与生成</strong>: AI将所有收集到的离散信息——接口、路由、VLAN、IP地址——在“脑中”构建成一个逻辑模型。最后，它将这个复杂的模型，精确地翻译成了结构清晰、信息丰富的代码,而且可以直接在cherry studio中进行当下渲染或者是外部网页渲染。</li></ol><p>AI返回的以下代码，无需任何手动修改，可直接渲染成一张专业级的网络拓扑图，完美地完成了这项艰巨的任务。</p><p><img src="/images/%E9%98%B2%E7%81%AB%E5%A2%99%E4%B8%8B%E7%9A%84%E7%BD%91%E7%BB%9C%E6%8B%93%E6%89%91%E5%9B%BE.png" alt="防火墙下的网络拓扑图"></p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>本次实践验证了通过 MCP 协议将大语言模型与网络设备整合的可行性与巨大潜力。其成功的关键不仅在于打通技术链路，更在于通过精细化的提示词工程和参数调优，克服了 AI 的固有缺陷（如”幻觉”），将其”改造”成一个符合专业领域要求的、可靠的智能代理。AIOps 的未来已来，而我们正处在这场变革的中心。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;基于MCP协议的AIOps实践：大语言模型与FortiGate防火墙的深度整合&lt;/p&gt;
&lt;p&gt;随着大语言模型（LLM）在各个领域的渗透，将其强大的认知与推理能力应用于传统的网络运维（NetOps）领域，即 AIOps，已成为业界探索的前沿方向。&lt;/p&gt;</summary>
    
    
    
    <category term="技术实践" scheme="https://grokfree.xyz/categories/%E6%8A%80%E6%9C%AF%E5%AE%9E%E8%B7%B5/"/>
    
    
    <category term="AIOps" scheme="https://grokfree.xyz/tags/AIOps/"/>
    
    <category term="大语言模型" scheme="https://grokfree.xyz/tags/%E5%A4%A7%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B/"/>
    
    <category term="FortiGate" scheme="https://grokfree.xyz/tags/FortiGate/"/>
    
    <category term="MCP协议" scheme="https://grokfree.xyz/tags/MCP%E5%8D%8F%E8%AE%AE/"/>
    
    <category term="网络运维" scheme="https://grokfree.xyz/tags/%E7%BD%91%E7%BB%9C%E8%BF%90%E7%BB%B4/"/>
    
  </entry>
  
  <entry>
    <title>本地快捷AI：手把手教你在电脑上部署 Gemini CLI</title>
    <link href="https://grokfree.xyz/2025/07/09/gemini%E9%83%A8%E7%BD%B2/"/>
    <id>https://grokfree.xyz/2025/07/09/gemini%E9%83%A8%E7%BD%B2/</id>
    <published>2025-07-09T03:30:00.000Z</published>
    <updated>2025-07-14T02:20:28.780Z</updated>
    
    <content type="html"><![CDATA[<p>GEMINI本地部署</p><span id="more"></span><h2 id="为什么我强烈推荐-Gemini-CLI？"><a href="#为什么我强烈推荐-Gemini-CLI？" class="headerlink" title="为什么我强烈推荐 Gemini CLI？"></a>为什么我强烈推荐 Gemini CLI？</h2><p>简单来说，它就是一个能在你命令行里直接和你对话的 AI。对我这样的实习生来说，用处实在太大了：</p><ul><li><strong>快速看懂老代码</strong>：直接把项目丢给它，问它“这个函数是干嘛的？”“项目的整体架构是啥？”，再也不用硬着头皮去问导师了。</li><li><strong>帮你写代码&#x2F;文档</strong>：写个工具函数、写个接口文档、甚至写 Git commit 信息，一句话的事儿。</li><li><strong>自动化处理文件</strong>：比如“把这个文件夹里所有的 JPG 图片转成 PNG”，它也能搞定。</li></ul><p>是不是很心动？下面是超简单的部署教程，三步搞定！</p><h2 id="第一步：检查环境"><a href="#第一步：检查环境" class="headerlink" title="第一步：检查环境"></a>第一步：检查环境</h2><p>在开始之前，我们需要确保电脑里装了 <strong>Node.js</strong>，并且版本不能太低，需要 <strong>v20 或更高版本</strong>。</p><p>打开你的终端（Windows 用户可以用 PowerShell 或 CMD，Mac 用户用自带的终端），输入下面的命令查看版本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node -v</span><br></pre></td></tr></table></figure><p>如果你的版本号是 <code>v20.x.x</code> 或者更高，那就没问题！如果不是，需要先去 <a href="https://nodejs.org/">Node.js 官网</a> 下载最新版安装一下。</p><h2 id="第二步：一键安装"><a href="#第二步：一键安装" class="headerlink" title="第二步：一键安装"></a>第二步：一键安装</h2><p>安装非常简单，我推荐用全局安装的方式，这样以后在任何地方都能随时召唤它。</p><p>继续在终端里输入这行命令，然后回车：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g @google/gemini-cli</span><br></pre></td></tr></table></figure><p>等待进度条跑完，看到一堆成功的提示就说明安装好了。</p><!-- 在这里可以放一张终端安装成功的截图 --><p>安装成功后，你可以输入 <code>gemini</code> 来启动它，第一次它会让你选一个喜欢的主题颜色，随便选一个就好。</p><h2 id="第三步：登录你的谷歌账号"><a href="#第三步：登录你的谷歌账号" class="headerlink" title="第三步：登录你的谷歌账号"></a>第三步：登录你的谷歌账号</h2><p>这是最关键的一步，也是最简单的一步。</p><p>当你第一次运行 <code>gemini</code> 命令后，它会自动在你的浏览器里打开一个谷歌登录页面。</p><p>你只需要<strong>登录你自己的个人 Google 账号</strong>，然后在授权页面点击“允许”就可以了。这一步是为了让 Gemini CLI 能使用 Google 的模型服务。</p><p><strong>放心，这个是免费的！</strong> 用个人账号登录后，你每天有 1000 次的免费请求额度，对于我们日常学习和工作来说，完全够用了！</p><p><img src="/images/gemini%E6%88%90%E6%9E%9C.png" alt="gemini success"></p><p>登录成功后，你的终端就会显示 <code>&gt; </code> 的提示符，恭喜你，现在可以开始使唤它了！</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>对于我们实习生来说，Gemini CLI 不仅仅是一个工具，它更像一个不知疲倦的导师。它能帮我们快速融入项目，解决开发中遇到的实际问题，把更多的时间花在学习核心业务和技术上。</p><p>部署过程非常简单，几乎零成本。强烈建议你也动手试试，体验一下 AI 辅助编程的快乐！<br>&#96;&#96;&#96;</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;GEMINI本地部署&lt;/p&gt;</summary>
    
    
    
    <category term="效率工具" scheme="https://grokfree.xyz/categories/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="Gemini" scheme="https://grokfree.xyz/tags/Gemini/"/>
    
    <category term="AI" scheme="https://grokfree.xyz/tags/AI/"/>
    
    <category term="效率工具" scheme="https://grokfree.xyz/tags/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/"/>
    
    <category term="实习" scheme="https://grokfree.xyz/tags/%E5%AE%9E%E4%B9%A0/"/>
    
    <category term="CLI" scheme="https://grokfree.xyz/tags/CLI/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://grokfree.xyz/2025/07/08/hello-world/"/>
    <id>https://grokfree.xyz/2025/07/08/hello-world/</id>
    <published>2025-07-08T06:47:06.069Z</published>
    <updated>2025-07-10T10:08:48.062Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><span id="more"></span><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for more info. If you get any problems when using Hexo, you can find the answer in &lt;a href=&quot;https://hexo.io/docs/troubleshooting.html&quot;&gt;troubleshooting&lt;/a&gt; or you can ask me on &lt;a href=&quot;https://github.com/hexojs/hexo/issues&quot;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
</feed>
